/*!
 * @pixi/unsafe-eval - v7.4.2
 * Compiled Wed, 20 Mar 2024 19:55:28 UTC
 *
 * @pixi/unsafe-eval is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
*/this.PIXI=this.PIXI||{};var _pixi_unsafe_eval=function(y,p){"use strict";const h={vec3(e,r,o,i){(o[0]!==i[0]||o[1]!==i[1]||o[2]!==i[2])&&(o[0]=i[0],o[1]=i[1],o[2]=i[2],e.uniform3f(r,i[0],i[1],i[2]))},int(e,r,o,i){e.uniform1i(r,i)},ivec2(e,r,o,i){e.uniform2i(r,i[0],i[1])},ivec3(e,r,o,i){e.uniform3i(r,i[0],i[1],i[2])},ivec4(e,r,o,i){e.uniform4i(r,i[0],i[1],i[2],i[3])},uint(e,r,o,i){e.uniform1ui(r,i)},uvec2(e,r,o,i){e.uniform2ui(r,i[0],i[1])},uvec3(e,r,o,i){e.uniform3ui(r,i[0],i[1],i[2])},uvec4(e,r,o,i){e.uniform4ui(r,i[0],i[1],i[2],i[3])},bvec2(e,r,o,i){e.uniform2i(r,i[0],i[1])},bvec3(e,r,o,i){e.uniform3i(r,i[0],i[1],i[2])},bvec4(e,r,o,i){e.uniform4i(r,i[0],i[1],i[2],i[3])},mat2(e,r,o,i){e.uniformMatrix2fv(r,!1,i)},mat4(e,r,o,i){e.uniformMatrix4fv(r,!1,i)}},b={float(e,r,o,i){e.uniform1fv(r,i)},vec2(e,r,o,i){e.uniform2fv(r,i)},vec3(e,r,o,i){e.uniform3fv(r,i)},vec4(e,r,o,i){e.uniform4fv(r,i)},int(e,r,o,i){e.uniform1iv(r,i)},ivec2(e,r,o,i){e.uniform2iv(r,i)},ivec3(e,r,o,i){e.uniform3iv(r,i)},ivec4(e,r,o,i){e.uniform4iv(r,i)},uint(e,r,o,i){e.uniform1uiv(r,i)},uvec2(e,r,o,i){e.uniform2uiv(r,i)},uvec3(e,r,o,i){e.uniform3uiv(r,i)},uvec4(e,r,o,i){e.uniform4uiv(r,i)},bool(e,r,o,i){e.uniform1iv(r,i)},bvec2(e,r,o,i){e.uniform2iv(r,i)},bvec3(e,r,o,i){e.uniform3iv(r,i)},bvec4(e,r,o,i){e.uniform4iv(r,i)},sampler2D(e,r,o,i){e.uniform1iv(r,i)},samplerCube(e,r,o,i){e.uniform1iv(r,i)},sampler2DArray(e,r,o,i){e.uniform1iv(r,i)}};function x(e,r,o,i,l){let v=0,u=null,f=null;const m=l.gl;for(const c in e.uniforms){const t=r[c],a=i[c],n=o[c],s=e.uniforms[c];if(!t){s.group===!0&&l.shader.syncUniformGroup(a);continue}t.type==="float"&&t.size===1&&!t.isArray?a!==n.value&&(n.value=a,m.uniform1f(n.location,a)):t.type==="bool"&&t.size===1&&!t.isArray?a!==n.value&&(n.value=a,m.uniform1i(n.location,Number(a))):(t.type==="sampler2D"||t.type==="samplerCube"||t.type==="sampler2DArray")&&t.size===1&&!t.isArray?(l.texture.bind(a,v),n.value!==v&&(n.value=v,m.uniform1i(n.location,v)),v++):t.type==="mat3"&&t.size===1&&!t.isArray?s.a!==void 0?m.uniformMatrix3fv(n.location,!1,a.toArray(!0)):m.uniformMatrix3fv(n.location,!1,a):t.type==="vec2"&&t.size===1&&!t.isArray?s.x!==void 0?(f=n.value,u=a,(f[0]!==u.x||f[1]!==u.y)&&(f[0]=u.x,f[1]=u.y,m.uniform2f(n.location,u.x,u.y))):(f=n.value,u=a,(f[0]!==u[0]||f[1]!==u[1])&&(f[0]=u[0],f[1]=u[1],m.uniform2f(n.location,u[0],u[1]))):t.type==="vec4"&&t.size===1&&!t.isArray?s.width!==void 0?(f=n.value,u=a,(f[0]!==u.x||f[1]!==u.y||f[2]!==u.width||f[3]!==u.height)&&(f[0]=u.x,f[1]=u.y,f[2]=u.width,f[3]=u.height,m.uniform4f(n.location,u.x,u.y,u.width,u.height))):(f=n.value,u=a,(f[0]!==u[0]||f[1]!==u[1]||f[2]!==u[2]||f[3]!==u[3])&&(f[0]=u[0],f[1]=u[1],f[2]=u[2],f[3]=u[3],m.uniform4f(n.location,u[0],u[1],u[2],u[3]))):(t.size===1&&!t.isArray?h:b)[t.type].call(null,m,n.location,n.value,a)}}function d(e){}function A(){Object.assign(p.ShaderSystem.prototype,{systemCheck(){},syncUniforms(e,r){const{shader:o,renderer:i}=this;x(e,o.program.uniformData,r.uniformData,e.uniforms,i)}})}return A(),y.install=d,y}({},PIXI);Object.assign(this.PIXI,_pixi_unsafe_eval);
//# sourceMappingURL=unsafe-eval.min.js.map
